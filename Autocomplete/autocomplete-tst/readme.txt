/******************************************************************************
 *  readme.txt template                                                   
 *  Autocomplete
**********************************************************************/

Name: 
NetID:  
Precept: 

Partner name: 
Partner login:    
Partner precept:  




/******************************************************************************
 * Describe your Autocomplete data structure. Make sure to include:
 * 1. How it locates the terms that match the query prefix.
 * 2. How it finds the top k terms among those matches.
 *****************************************************************************/


/******************************************************************************
 * Let Np be the number of terms that match a query prefix. In the
 * best case, does your algorithm look at fewer than Np weights? 
 * If so, describe an example input where fewer than Np weights
 * are examined.
 *****************************************************************************/


/******************************************************************************
 * For BruteAutocomplete and Autocomplete, how many calls per second 
 * to topMatches(String prefix, k=2) can be completed if you 
 * use random 2-letter prefixes?
 *****************************************************************************/
 
BruteAutocomplete:


Autocomplete:

/******************************************************************************
 *  If you completed any of the extra credit, explain what you did
 *  here. If you created a new dataset, and have code which can 
 *  automatcally update the dataset, we're happy to have that as well.
 *****************************************************************************/


/******************************************************************************
 *  Known bugs / limitations.
 *****************************************************************************/

/******************************************************************************
 *  Describe whatever help (if any) that you received.
 *  Don't include readings, lectures, and precepts, but do
 *  include any help from people (including course staff, lab TAs,
 *  classmates, and friends) and attribute them by name.
 *
 *  Also include any resources (including the web) that you may
 *  may have used in creating your design.
 *****************************************************************************/


/******************************************************************************
 *  Describe any serious problems you encountered.                    
 *****************************************************************************/

/******************************************************************************
 *  List any other comments here. Feel free to provide any feedback   
 *  on how much you learned from doing the assignment, and whether    
 *  you enjoyed doing it.                                             
 *****************************************************************************/

/******************************************************************************
 *  Lecture topics theory questions (last set!)
 *
 *  It is ok to discuss these in any level of detail
 *  with anyone, including students outside your group,
 *  but do not submit an answer without fully understanding it.
 *
 *  You are encouraged to attempt to solve the problems with as
 *  little help as possible, simply because you'll probably learn 
 *  more in so doing. It's up to you.
 * 
 *  1. Both DFAs and NFAs can be used to match a regex. In general,
 *     which takes longer to construct? Which takes longer to 
 *     simulate?
 * 
 *  2. Fill in the two blanks from problem 7b of the Spring 2013
 *     Final: http://goo.gl/fNHWsx (it is ok to look at the 
 *     solution)
 *    
 *  3. Suppose we have some input bitstream X, and we use Huffman
 *     coding to produce a compressed bitstream C, where C
 *     includes the coding trie as well as the coded version of X.
 *     If we apply Huffman coding to C, is it possible for the
 *     resulting bitstream to be shorter than C? Why or why not?
 *
 *  4. Suppose we use LZW (as discussed in class, with a fixed
 *     codeword table that eventually fills up) on a bitstream X
 *     to produce compressed bitstream C. If we apply LZW again,
 *     is it possible for the resulting bitstream to be shorter 
 *     than C? Why or why not?
 *****************************************************************************/
  
